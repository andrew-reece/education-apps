{"files":[{"id":"d5475b33-d91a-4e37-9470-df12a89e93ee","name":"Code","type":"server_js","source":"//####################################################################################################\n//####################################################################################################\n\n// purpose: returns calendar id string\nfunction getCalendarId() {\n  \n  var id \u003d \"qhcavu6jim95ime2tovcjmje4s@group.calendar.google.com\" // id for \u0027psets MWF\u0027 cal on dharmahound \n  \n  return id\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: returns spreadsheet id string\nfunction getSpreadsheetId() {\n  \n  var id \u003d \"0Ai1RU2ey21bfdHZHWFc0MUFrVUcxbmY0WFRqeTVvblE\"\n  \n  return id\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: returns column index of time variable from pset-helper spreadsheet\nfunction getTimeIndex(id) {\n  \n  var sheet \u003d SpreadsheetApp.openById(id).getActiveSheet()\n  var numcol \u003d sheet.getLastColumn()\n  var first_row \u003d sheet.getRange(1,1,1,numcol).getValues()[0]\n  \n  for (var col in first_row) { if (first_row[col] \u003d\u003d \"time\") { var time_idx \u003d parseInt(col)+1 } }\n  \n  return time_idx\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// name: arrayTranspose(data)\n// purpose: given a 2d Array, this function returns the transposed table\n//          from https://developers.google.com/apps-script/guides/sheets\n// input:  Array data\n// output: Array ret\n//         eg. arrayTranspose([[1,2,3],[4,5,6]]) returns [[1,4],[2,5],[3,6]]\n\nfunction arrayTranspose(data) {\n  \n  if (data.length \u003d\u003d 0 || data[0].length \u003d\u003d 0) {\n    return null;\n  }\n\n  var ret \u003d [];\n  for (var i \u003d 0; i \u003c data[0].length; ++i) {\n    ret.push([]);\n  }\n\n  for (var i \u003d 0; i \u003c data.length; ++i) {\n    for (var j \u003d 0; j \u003c data[i].length; ++j) {\n      ret[j][i] \u003d data[i][j];\n    }\n  }\n\n  return ret;\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: rounds minutes to nearest half hour\nfunction roundMinutes(id) {\n\n  var sheet \u003d SpreadsheetApp.openById(id).getActiveSheet()\n  var numrow \u003d sheet.getLastRow()\n\n  var time_idx \u003d getTimeIndex(id)\n  \n  var time_col \u003d sheet.getRange( 2, time_idx, numrow-1 )\n  var time_col_array \u003d time_col.getValues()\n  \n  //Logger.log(\"TIME COL: \"+time_col)\n\n  for (var t in time_col_array) {\n     \n    // we subtract 2 from time_idx here to account for:\n    //                                                  a) spreadsheet is 1-indexed but this is 0-indexed\n    //                                                  b) we started at i \u003d 1 to skip the timestamp column\n    var time_string \u003d time_col_array[t].toString()\n    var time_chunks \u003d time_string.split(\" \")\n    var time \u003d time_chunks[4].slice(0,5)\n    var hour \u003d time.slice(0,2)\n    var min \u003d time.slice(3,5)\n    var min_int \u003d parseInt(min)\n    \n    if ((min_int !\u003d 0) \u0026\u0026 (min_int !\u003d 30)) {\n      \n      // if we have to round up to the next hour, we must change \u0027hour\u0027 var also\n      if ((min_int \u003e\u003d 45) \u0026\u0026 (min_int \u003c 60)) { min \u003d \u002700\u0027; hour \u003d parseInt(hour)+1 }\n      else if (min_int \u003c 15) { min \u003d \u002700\u0027 }\n      else { min \u003d \u002730\u0027 }\n      \n    }\n  \n    time \u003d hour + \":\" + min\n    time_col_array[t] \u003d time\n  \n  }\n  \n  var new_times \u003d arrayTranspose([time_col_array])\n  time_col.setValues(new_times)\n  \n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: gets array of all cell values from spreadsheet\nfunction getAllValues(id) {\n  \n  var sheet \u003d SpreadsheetApp.openById(id)\n  var range \u003d sheet.getDataRange()\n  var vals \u003d range.getValues()\n  \n  return vals\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: subroutine for checkMatches(), makes arrays for each column in spreadsheet\nfunction makeCols(headers) {\n  \n  cols \u003d new Array()\n  \n  for (h in headers) { cols[headers[h]] \u003d new Array() }\n    \n  return cols\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// fills column arrays with cell values\nfunction getUserRows(vals, headers, id) {\n  \n  var user_rows \u003d new Array()\n  \n  for (var i \u003d 1; i \u003c vals.length; i++) {\n   \n    var user_row \u003d vals[i].slice(1)\n    \n    user_rows.push(user_row)\n    \n    //Logger.log(\u0027user_row:\u0027+user_row)\n\n  }\n  \n  return user_rows\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: gets unique values in array\n// from: http://stackoverflow.com/questions/1960473/unique-values-in-an-array\nfunction onlyUnique(value, index, self) { \n  \n    return self.indexOf(value) \u003d\u003d\u003d index;\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: get array of each unique combo of time/date/pset/subpset\nfunction getUniqueSets(rows) {\n    \n  var noemail_rows \u003d new Array()\n  \n  for (var user in rows) {\n    \n    var temp \u003d rows[user].slice(1)\n    \n    noemail_rows.push(temp.join(\"_\"))\n    \n  }\n  \n  var unique_sets \u003d noemail_rows.filter(onlyUnique)  \n  \n  return unique_sets\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: gets user rows that match each unique combo of time/date/pset/subpset\nfunction getMatches(sets, rows) {\n  \n  var matches \u003d new Array()\n  \n  for (var i \u003d 0; i \u003c sets.length; i++) {\n    \n    var this_set \u003d sets[i]\n    var targets \u003d this_set.split(\"_\")\n    \n    matches[i] \u003d new Array()\n    \n    for (var j \u003d 0; j \u003c rows.length; j++) {\n      \n      var user_row \u003d rows[j]\n      \n      var hopefuls \u003d user_row.slice(1) // excludes first cell (email address)\n\n      var pset_match \u003d (hopefuls[0] \u003d\u003d targets[0])\n      var sub_pset_match \u003d (hopefuls[1] \u003d\u003d targets[1])\n      var date_match \u003d (hopefuls[2] \u003d\u003d targets[2])\n      var exact_time_match \u003d (hopefuls[3] \u003d\u003d targets[3])\n      \n      var hopeful_d \u003d new Date(hopefuls[3])\n      var target_d \u003d new Date(targets[3])\n      // with help from: http://stackoverflow.com/questions/1197928/how-to-add-30-minutes-to-a-javascript-date-object\n      var milisec_30min \u003d 30*60000\n      var user_too_early \u003d (hopeful_d.getTime() + milisec_30min \u003d\u003d target_d.getTime())\n      var user_too_late \u003d (hopeful_d.getTime() - milisec_30min \u003d\u003d target_d.getTime())\n      \n      if (exact_time_match)    { hopefuls[4] \u003d \"exact\" }\n      else if (user_too_early) { hopefuls[4] \u003d \"30_too_early\" } \n      else if (user_too_late)  { hopefuls[4] \u003d \"30_too_late\" } \n      else                     { hopefuls[4] \u003d \"way_off\" } \n      \n      var target_time \u003d targets[3].toString().split(\" \")[4]\n      \n      var hopeful_time \u003d hopefuls[3].toString().split(\" \")[4]\n      var hour \u003d parseInt(hopeful_time.slice(0,2))\n      var min \u003d hopeful_time.slice(3,5)\n      \n      if (min \u003d\u003d 0) {\n        \n        var new_min \u003d \"30\"\n        var new_hour \u003d hour - 1\n        \n        var time_forward \u003d hour + \":\" + new_min + \":00\"\n        var time_back \u003d new_hour + \":\" + new_min + \":00\"\n        \n      } else if (min \u003d\u003d 30) {\n        \n        var new_min \u003d \"00\"\n        var new_hour \u003d hour + 1\n        \n        var time_forward \u003d new_hour + \":\" + new_min + \":00\"\n        var time_back \u003d hour + \":\" + new_min + \":00\"\n      }\n      \n      hopefuls[5] \u003d time_forward  \n      hopefuls[6] \u003d time_back \n      \n      if ((pset_match) \u0026\u0026 (sub_pset_match) \u0026\u0026 (date_match)) {\n        \n        if (matches[i].length \u003d\u003d 0) {\n          \n          var full_info \u003d [hopefuls[0], hopefuls[1], hopefuls[2], hopeful_time]\n          var match_data \u003d [full_info, user_row[0], hopefuls[4], hopefuls[5], hopefuls[6]]\n          \n        } else { var match_data \u003d [user_row[0], hopefuls[4], hopefuls[5], hopefuls[6]] }\n            \n        //Logger.log(\u0027MATCH DATA: \u0027+match_data)\n        \n        matches[i].push(match_data)\n      }\n    } \n  } \n  \n  return matches\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: cross refs matches on timeslot with available rooms to study\n// these rooms are posted to gcal by TFs (or maybe students too?  2 calendars in that case?)\nfunction getLocationsByTime(date, hr, min) {\n \n  var cal_id \u003d getCalendarId()\n  var cal \u003d CalendarApp.getCalendarById(cal_id)\n  \n  var requested_time \u003d hr + \u0027\u0027 + min\n  \n  var yr \u003d new Date().getFullYear()\n  var tmp \u003d date.split(\" \")\n  var day \u003d tmp[1]\n  var month \u003d tmp[0]\n  \n  // changes str to num for month (eg. \u0027Dec\u0027 to \u002711\u0027)\n  var month_names \u003d [\u0027Jan\u0027, \u0027Feb\u0027, \u0027Mar\u0027, \u0027Apr\u0027, \u0027May\u0027, \u0027Jun\u0027, \u0027Jul\u0027, \u0027Aug\u0027, \u0027Sep\u0027, \u0027Oct\u0027, \u0027Nov\u0027, \u0027Dec\u0027]\n  for (var idx in month_names) { if (month \u003d\u003d month_names[idx]) { month \u003d idx } }\n  \n  var day_of_events \u003d new Date(yr, month, day)\n  var day_start \u003d day_of_events.getTime()\n  var events \u003d cal.getEventsForDay(day_of_events)\n  \n  var loc_and_endtime \u003d new Array()\n  \n  for (var ev in events) {\n    \n    var location \u003d events[ev].getTitle()\n    var location_good_until \u003d events[ev].getEndTime().toString().split(\" \")[4].slice(0,5)\n    \n    var event_start \u003d events[ev].getStartTime()\n    var tmp \u003d event_start.toString().split(\" \")\n    var event_start_time \u003d tmp[4].slice(0,2)+tmp[4].slice(3,5)\n    \n    var event_end \u003d events[ev].getEndTime()\n    var tmp \u003d event_end.toString().split(\" \")\n    var event_end_time \u003d tmp[4].slice(0,2)+tmp[4].slice(3,5)\n    \n    if ((event_start_time \u003d\u003d requested_time) || ((event_start_time \u003c requested_time) \u0026\u0026 (event_end_time \u003e requested_time))) {\n      \n      var info \u003d location + \"_\" + location_good_until\n      \n      loc_and_endtime.push([location, location_good_until, [yr, month, day, hr, min]]) \n    }\n  }\n  \n  return loc_and_endtime\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: changes 24-hr time to 12-hr time with AM/PM\nfunction timeToString(hr, min) {\n  \n  if (hr \u003e 12) { var time \u003d hr-12 + \u0027:\u0027 + min  + \u0027PM\u0027 } \n  else { var time \u003d hr + \u0027:\u0027 + min + \u0027AM\u0027 } \n  \n  return time\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: formats location and end time for email body text\nfunction formatLocationText(tmp) {\n\n  var text \u003d new Array()\n  \n  for (idx in tmp) {\n    \n    var h \u003d tmp[idx][1].slice(0,2)\n    var m \u003d tmp[idx][1].slice(3,5)\n        \n    text.push(\"       \" + tmp[idx][0]+ \" is available until \" + timeToString(h,m) + \"\\n\\n\")\n  }  \n  \n  return text.join(\"\")\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: format Date/Location info into email text\nfunction getLocationText(date, hour, min) {\n  \n  var location_data \u003d getLocationsByTime(date, hour, min)\n  var location_info_text \u003d formatLocationText(location_data)\n  \n  //Logger.log(\u0027location info: \u0027+location_info_text)\n  \n  var text \u003d (location_info_text \u003d\u003d \"\") ? \"\" : \"Alternately, you can meet up at an official study location.\\n\\n\"\n  + location_info_text \n  \n  return text\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: gets text of email for exact date/time/pset matches\nfunction getExactEmailText(users, pset, date, hour, min) {\n  \n  var location_html \u003d getLocationText(date, hour, min)\n  var time \u003d hour + \":\" + min\n  \n  var emails \u003d new Array()\n  for (var i \u003d 0; i \u003c users.length; i++) { emails.push(users[i][0]) }\n  \n  var to \u003d emails.toString()\n  var from \u003d \u0027Mathbook Helper\u0027\n  var subject \u003d \u0027Good news! Someone wants to help you with Pset \u0027+pset+\u0027!\u0027\n  var body \u003d \"So it turns out you\u0027re not the only one who wants to work on pset \"+pset\n              +\" on \"+date+\" at \"+time\n              +\".\\n\\n\"\n              +\"Just \\\"reply all\\\" to this email and y\u0027all can figure out where to meet!\\n\\n\" \n              + location_html \n  \n  return [to, from, subject, body]\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: gets text of email for too early matches\nfunction getTooLateEmailText(users, f_users, pset, date, hour, min) {\n  \n  //Logger.log(\"USERS: \"+users)\n  //Logger.log(\"F_USERS: \"+f_users)\n  \n  var orig_time \u003d users[0][1].toString().slice(0,5)\n  var new_time \u003d users[0][2].toString().slice(0,5)\n  \n  var emails \u003d new Array()\n  for (var i \u003d 0; i \u003c users.length; i++) { emails.push(users[i][0]) }\n  \n  var forward_emails \u003d \"\"\n  for (var j \u003d 0; j \u003c f_users.length; j++) { forward_emails +\u003d \"          \"+f_users[j][0]+ \"\\n\" }\n  \n  var to \u003d emails.toString()\n  var from \u003d \u0027Mathbook Helper\u0027\n  var subject \u003d \u0027Can you come 30 min later to work on Pset \u0027+pset+\u0027?\u0027\n  var body \u003d \"We haven\u0027t found other students who want to work on Pset \"+pset\n              +\" on \"+date+\" at exactly \"+ orig_time\n              +\" yet, but at least one person wants to start working 30 min after that, at \"+new_time\n              +\".\\n\\n\"\n              +\"Can you make that work?  If so, please get in touch with your classmates!\\n\\n\"\n              +\"Here are the email addresses of people who want to work at \"+new_time+\":\\n\\n\" \n              + forward_emails + \"\\n\\n\"\n  \n  return [to, from, subject, body]\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: gets text of email for too late matches\nfunction getTooEarlyEmailText(users, b_users, pset, date, hour, min) {\n\n  var orig_time \u003d users[0][1].toString().slice(0,5)\n  var new_time \u003d users[0][3].toString().slice(0,5)\n  \n  var emails \u003d new Array()\n  for (var i \u003d 0; i \u003c users.length; i++) { emails.push(users[i][0]) }\n  \n  var backward_emails \u003d \"\"\n  for (var j \u003d 0; j \u003c b_users.length; j++) { backward_emails +\u003d \"          \" + b_users[j][0] + \"\\n\" }\n  \n  var to \u003d emails.toString()\n  var from \u003d \u0027Mathbook Helper\u0027\n  var subject \u003d \u0027Can you come 30 min earlier to work on Pset \u0027+pset+\u0027?\u0027\n  var body \u003d \"We haven\u0027t found other students who want to work on Pset \"+pset\n              +\" on \"+date+\" at exactly \"+ orig_time\n              +\" yet, but at least one person wants to start working 30 min before that, at \"+new_time\n              +\".\\n\\n\"\n              +\"Can you make that work?  If so, please get in touch with your classmates!\\n\\n\"\n              +\"Here are the email addresses of people who want to work at \"+new_time+\":\\n\\n\"\n              + backward_emails + \"\\n\\n\"\n  \n  return [to, from, subject, body]\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: sends email out to users\nfunction sendMail(data) {\n  \n  var to \u003d data[0]; var from \u003d data[1]; var subject \u003d data[2]; var body \u003d data[3]  \n  \n  MailApp.sendEmail({\n    to: to,\n    from: from,\n    subject: subject,\n    body: body,  \n  });\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: sends out emails to people who matched on timeslots, letting them know\nfunction sendMatchEmails(matches) {\n  \n  var emails_sent \u003d new Array()\n  \n  for (var m in matches) {\n    \n    Logger.log(\"MATCHES[M]: \"+matches[m])\n    var pset \u003d matches[m][0][0][0]\n    \n    var sub_pset \u003d (matches[m][0][0][1] \u003d\u003d \"Not sure/All of them\") ? \"\" : matches[m][0][0][1]\n    \n    var full_pset \u003d pset + sub_pset\n    \n    var date \u003d matches[m][0][0][2]\n    var time \u003d matches[m][0][0][3]\n    var hour \u003d time.slice(0,2)\n    var min \u003d time.slice(3,5)\n    \n    var set \u003d full_pset + \" \" + date + \" \" + time\n    //Logger.log(\u0027MATCH ITEMS: \u0027+ set)\n    \n    if (matches[m].length \u003e 1) {\n      \n      var match_set \u003d matches[m]\n      \n      var exact_users \u003d new Array()\n      var too_early_users \u003d new Array()\n      var too_late_users \u003d new Array()\n      \n      for (var user in match_set) {\n        \n        //Logger.log(\"USER: \"+match_set[user])\n        \n        // we use negative indices here because the first user in each array also has pset info at the array front\n        // these indices work assuming: backward \u003d last, forward \u003d 2nd-to-late, email \u003d 3rd-to-last\n        \n        var len \u003d match_set[user].length\n        \n        var forward \u003d match_set[user][len-2]\n        var backward \u003d match_set[user][len-1]\n        var match_status \u003d match_set[user][len-3]\n        var email \u003d match_set[user][len-4]\n        \n        // we need to keep track of who\u0027s been emailed already\n        // there is probably a more efficient way to do this - maybe not cycling through by matches, for example\n        // but for now, we use 0/1 indexes to log whether we already sent an exact, too early, or too late email\n        // if exact is sent, then no more get sent at all\n        // if no exact but too early or too late are sent, then the complement can also be sent\n        // that means we need to figure out how to look first for exacts?\n        \n        // [email, exact_email_sent, too_early_email_sent, too_late_email_sent]\n        var exact_ct \u003d 0\n        var early_ct \u003d 0\n        var late_ct  \u003d 0\n        var full_ct \u003d 0\n        var found \u003d false\n        \n        var email_list \u003d (emails_sent.length \u003e 0) ? emails_sent.keys() : null \n        \n        if (email_list) {\n          \n          for (var i \u003d 0; i \u003c email_list.length; i++) {\n            \n            if (email \u003d\u003d email_list[i]) {\n              \n              found \u003d true\n              if (emails_sent[email][1] \u003d\u003d 1) { exact_ct \u003d 1 }\n              else if ((emails_sent[email][2] \u003d\u003d 1) \u0026\u0026 (emails_sent[email][3] \u003d\u003d 1)) { full_ct \u003d 1 }\n              else if ((emails_sent[email][2] \u003d\u003d 1) \u0026\u0026 (emails_sent[email][3] \u003d\u003d 0)) { early_ct \u003d 1 }\n              else if ((emails_sent[email][2] \u003d\u003d 0) \u0026\u0026 (emails_sent[email][3] \u003d\u003d 1)) { late_ct \u003d 1 }\n              \n            }\n          }\n        }\n        if (exact_ct \u003d\u003d 1) { continue; } // skip everything if exact email match is already sent\n        else if (!found) { emails_sent[email] \u003d [0,0,0] } // if no record at all, start one\n        \n        Logger.log(\"MATCH STATUS: \"+match_status)\n        if (match_status \u003d\u003d \u0027exact\u0027) { exact_users.push([email, time, forward, backward]) } // means exact match found\n        \n        else if (match_status \u003d\u003d \u0027too_late\u0027) { too_late_users.push([email, time, forward, backward]) } // means backward time was found\n        \n        else if (match_status \u003d\u003d \u0027too_early\u0027) { too_early_users.push([email, time, forward, backward]) } // means forward time was found\n        \n      }\n      \n      var match_found \u003d (exact_users.length \u003e 1)\n      \n      if (match_found) {\n        \n        var exact_text \u003d getExactEmailText(exact_users, pset, date, hour, min)\n        Logger.log(\"EXACT: \"+exact_text)\n        //sendMail(exact_text)\n   \n        if (too_early_users.length \u003e 0) {\n        \n          var early_text \u003d getTooLateEmailText(too_early_users, exact_users, pset, date, hour, min)\n          \n          Logger.log(\"REG F: \"+early_text)\n        //sendMail(exact_text)\n          \n        }  \n        if (too_late_users.length \u003e 0) {\n          \n          var late_text \u003d getTooEarlyEmailText(too_late_users, exact_users, pset, date, hour, min)\n          Logger.log(\"REG B : \"+late_text)\n        //sendMail(exact_text)\n          \n        }\n      } else {\n        \n        if (too_early_users.length \u003e 0) {\n         \n          var exact_text \u003d getTooLateEmailText(exact_users, too_early_users, pset, date, hour, min)\n          \n          Logger.log(\"EXACT F: \"+exact_text)\n        //sendMail(exact_text)\n        }\n        \n        if (too_late_users.length \u003e 0) {\n          \n          var exact_text \u003d getTooEarlyEmailText(exact_users, too_late_users, pset, date, hour, min)\n          Logger.log(\"EXACT B: \"+exact_text)\n        //sendMail(exact_text)\n          \n        }\n      }\n      \n    }  \n  }  \n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: capitalizes first letter of a string\n// from: http://bit.ly/18N7Nsp\nfunction capitalizeFirstLetter(string)\n{\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\n//####################################################################################################\n//####################################################################################################\n\n//////////////////////////////////////\n/////                          ///////\n/////  MAIN MATCHING FUNCTION  ///////\n/////      checkMatches()      ///////\n//////////////////////////////////////\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: identify groups looking to work together on same pset at same date/time\nfunction checkMatches() {\n\n  var spreadsheet_id \u003d getSpreadsheetId()\n  \n  roundMinutes(spreadsheet_id)\n  \n  var vals \u003d getAllValues(spreadsheet_id)\n  \n  var headers \u003d vals[0].slice(1)\n  \n  var cols \u003d makeCols(headers)\n  \n  var user_rows \u003d getUserRows(vals, headers, spreadsheet_id)\n  \n  var unique_sets \u003d getUniqueSets(user_rows)\n\n  var email_matches \u003d getMatches(unique_sets, user_rows)\n\n  sendMatchEmails(email_matches, unique_sets)\n}\n\n\n\n\n\n\n//####################################################################################################\n//####################################################################################################\n//\n//     START EMAIL CHECKING FUNCTION BLOCK\n//\n//####################################################################################################\n//####################################################################################################\n\n\n// purpose: gets timestamp from last row in spreadsheet\n//          this is so the Gmail reader function only considers messages sent after the last checking\nfunction getMostRecentTimestamp(id) {\n \n  var sheet \u003d SpreadsheetApp.openById(id)\n  var last_row \u003d sheet.getLastRow()\n  var timestamp_cell \u003d \u0027A\u0027+last_row\n  \n  var timestamp \u003d sheet.getRange(timestamp_cell).getValue()\n  var date \u003d new Date(timestamp)\n\n  return date\n  \n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: finds email threads relevant to our search, via subject\nfunction matchThreadSubject(thread) {\n  \n  var subject \u003d thread.getFirstMessageSubject()\n  //Logger.log(subject)\n  var match1 \u003d subject.match(/(SMS\\s{1}from)/)  \n  var match2 \u003d subject.match(/(pset[ ]?helper)/)\n  \n  \n  return (match1 || match2)\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: gets \u0027from\u0027 email address\nfunction getFrom(msg) {\n  \n  var from \u003d msg.getFrom()\n  \n  // gmail returns a full address string, eg. \"Reece, Andrew\" \u003creece@g.harvard.edu\u003e\n  // but we only want the email address itself. so use regex to pattern match what\u0027s inside the \u003c \u003e\n  \n  // learned how to access matched groups in javascript here: http://bit.ly/1cU09IB\n  \n  var email_pattern \u003d /\\\u003c(.*)\\\u003e/\n  var match \u003d email_pattern.exec(from)\n  \n  // not all email addresses will have the extra text.  \n  // but if they do, replace with simple email address.\n  \n  if (match) { from \u003d match[1] }  \n  \n  return from\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: gets pset info from email body\nfunction getPset(body) {\n  \n  var pset_pattern \u003d \"pset\\\\s*(\\\\d{1,2})\\\\s?([ABC]{0,3})\"\n  var pset_regex \u003d new RegExp(pset_pattern, \"i\")\n  var pset_match \u003d pset_regex.exec(body)\n  \n  var sub_pset_regex \u003d /^[ABC]{1}$/i\n  \n  if (pset_match[1]) { var pset \u003d pset_match[1] }\n  \n  //Logger.log(\u0027subpset: \u0027+sub_pset_regex.exec(pset_match[2]))\n  \n  if (sub_pset_regex.exec(pset_match[2])) { var sub_pset \u003d capitalizeFirstLetter(pset_match[2]) }  \n  else { var sub_pset \u003d \"\" }\n  \n  return [pset, sub_pset, pset_pattern]\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: uses regex to scrape email body for date/time info\nfunction getDateTimeInfo(pset, body) {\n  \n  var day_descrip \u003d \"(today|tomorrow|tom)\"\n  var day_short \u003d \"mon|tue|wed|thu|fri|sat|sun\"\n  var day_long \u003d \"monday|tuesday|wednesday|thursday|friday|saturday|sunday\"\n  var month_short \u003d \"jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec\"\n  var month_long \u003d \"january|february|march|april|may|june|july|august|september|october|november|december\"\n  var month_num \u003d \"[0-9]{1,2}(?\u003d[\\\\/|-|\\\\s])\"\n  var date \u003d \"[0-9]{1,2}(?\u003d[\\\\s|at|@])\"\n  var hour \u003d \"[0-9]{1,2}\"\n  var min \u003d \"[0-9]{1,2}\"\n  var datetime_pattern \u003d new RegExp(\"(\" + pset + \")\\\\n*\\\\W*\" + day_descrip + \"?\\\\W*\" +\n                                    \"(\"+ day_long + \"|\" + day_short + \")?\\\\W*\" +\n                                    \"(\"+ month_long + \"|\" + month_short + \"|\" + month_num + \")?\\\\W*\" +\n                                    \"(\" + date + \")?\\\\W*\" +\n                                    \"(at|@)?\\\\s*\" +\n                                    \"(\" + hour + \")?\\\\:?(\" + min + \")?(pm|am)?\\\\s*\" +\n                                    \"(or|and)?\\\\s*\" +\n                                    \"(\" + hour + \")?\\:?(\" + min + \")?(pm|am)?\\\\s*\", \"gim\")\n  \n  var match \u003d datetime_pattern.exec(body)  \n  for (m in match) {\n    //Logger.log(match[m])\n  }\n  \n  return cleanDateTimeInfo(match)\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: converts 12-hr times to 24-hr format\nfunction convertTo24(hr, am_pm) {\n  \n  // first check if cell for \u0027am/pm\u0027 values has data\n  var am_pm_set \u003d (am_pm)\n  var pm \u003d false\n  \n  // if so, see if it\u0027s pm (or PM)\n  // we only care about PM times for converting to 24-hr format...in AM it\u0027s all the same\n  if (am_pm_set) {\n    var pm_pattern \u003d /pm/i\n    var pm \u003d am_pm.match(pm_pattern)\n  }\n  \n  // boolean variable: TRUE \u003d time is in 12hr format \n  //                   NB:    technically this doesn\u0027t tell us that it\u0027s in 12 hr format\n  //                          it could just be 24-hr format before noon\n  //                          but we test for am/pm concurrently with this on the if statement below\n  var format_12hr \u003d (hr \u003c 12)\n  \n  // if \u0027pm\u0027 is entered and the hour is \u003c12, then we add 12 to convert to 24-hr format\n  \n  if (pm \u0026\u0026 format_12hr) { hr \u003d parseInt(hr) + 12 } \n  \n  return hr\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: fix potential regex errors in parsing time backmatching\nfunction fixTimeRegex(hr, min) {\n  \n  // here we have to check if regex messed with our hours/minutes\n  // in the case where it\u0027s a 1-digit hour (eg. 6) and user provides no \":\" between hr and min,\n  // then in the example (630pm), regex matching {1,2} digits for hour will grab \"63\", and min then \u003d \"0\"\n  // this block of code checks for those cases and fixes them.\n  \n  //Logger.log(\"VAL: \"+hr)\n  //Logger.log(\"VAL[0]: \"+hr[0])\n  //Logger.log(\"VAL[1]: \"+hr[1])\n  //Logger.log(\"DTM[10]: \"+min)\n  \n  // this is only a problem if minutes.length \u003d 1\n  // that means regex ate the minutes \u002710s\u0027 column into the hours backref\n  \n  if (min.length \u003d\u003d 1) {\n    \n    // val[1] is the first digit (ie. 10s column) of minutes. \n    // reassign val[1] here because val is written over on next line with val \u003d val[0]\n    var min_tens_column \u003d hr[1] \n    \n    // val[0] is the hour.   \n    hr \u003d hr[0]\n    \n    // now change the minutes value in datetime_match[10] ... append val[1] in front of current value\n    // concatenation with \"\" in the middle to ensure it\u0027s typed as a string\n    min \u003d min_tens_column + \"\" + min\n    \n  }  \n  \n  return [hr, min]\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: cleans up date and time info for entry into spreadsheet\nfunction cleanDateTimeInfo(datetime_match) {\n  \n  // now we have regex pattern-matched groups in an array\n  // we have to sort through them and assign to appropriate variables\n  // we can hard code indices, as long as the regex pattern itself isn\u0027t changed\n  // eg. idx 9 is always \u0027hour\u0027 of availablilty\n  \n  \n  // if no minutes are entered, this is default value\n  var min \u003d \u002700\u0027\n  //Logger.log(datetime_match)\n  \n  for (var i \u003d 3; i \u003c datetime_match.length; i++) {\n    \n    var val \u003d datetime_match[i]\n    \n    if (val) {\n      \n      if (i \u003d\u003d 4) {\n      \n        var tom_pattern \u003d new RegExp(\"(tomorrow|tommorow|tomorow|tommorow|tom|tmrw)\",\"i\")\n        var tod_pattern \u003d new RegExp(\"(today|tod|tdy)\",\"i\")\n        \n        var tomorrow \u003d tom_pattern.exec(val)\n        var today \u003d tod_pattern.exec(val)\n        \n        var d \u003d new Date()\n        \n        if (tomorrow) { d.setDate(d.getDate() + 1) }\n        \n        var date_array \u003d d.toString().split(\" \")\n        datetime_match[6] \u003d date_array[1] // month value\n        datetime_match[7] \u003d date_array[2] // day value\n        \n        //Logger.log(\"TODTOM: \"+val)\n        //Logger.log(\"DATE: \"+datetime_match[6]+\" \"+datetime_match[7])\n        \n      } else if (i \u003d\u003d 5) {\n        \n        var weekdays \u003d [\u0027Sun\u0027, \u0027Mon\u0027, \u0027Tue\u0027, \u0027Wed\u0027, \u0027Thu\u0027, \u0027Fri\u0027, \u0027Sat\u0027]\n        \n        // get day of week into 3-character, first-letter-caps format\n        if (val.length \u003e 3) { var weekday \u003d capitalizeFirstLetter(val.slice(0,3)) }\n        else { var weekday \u003d capitalizeFirstLetter(val) }\n        \n        //Logger.log(\"WEEKDAY: \"+weekday)\n        \n        for (var day in weekdays) { if (weekday \u003d\u003d weekdays[day]) { var day_idx \u003d day } }\n        \n        //Logger.log(\"DAY IDX: \"+day_idx)\n        \n        var d \u003d new Date()\n        var today \u003d d.getDay()\n        \n        // get Date object for the nearest upcoming given weekday \n        // eg. given \u0027Thursday\u0027 on a Friday, get next Thu Date()\n        // slightly modified from: http://stackoverflow.com/questions/11789647/setting-day-of-week-in-javascript \n        \n        var distance \u003d (day_idx - today) \n        if (distance \u003c 0) { distance \u003d 7 - Math.abs(distance) }\n        //Logger.log(\"DISTANCE FROM TODAY: \"+distance)\n        \n        d.setDate(d.getDate() + distance);\n        \n        var target_date \u003d d.toString().split(\" \")\n        //Logger.log(\"TARGET DATE: \"+target_date)\n        \n        datetime_match[6] \u003d target_date[1]\n        datetime_match[7] \u003d target_date[2]\n          \n        \n      } else if (i \u003d\u003d 6) { // idx 6 for month\n        \n        var month_names \u003d [\u0027Jan\u0027, \u0027Feb\u0027, \u0027Mar\u0027, \u0027Apr\u0027, \u0027May\u0027, \u0027Jun\u0027, \u0027Jul\u0027, \u0027Aug\u0027, \u0027Sep\u0027, \u0027Oct\u0027, \u0027Nov\u0027, \u0027Dec\u0027]\n        \n        if (parseInt(val)) { var month \u003d month_names[parseInt(val)-1] } \n        \n        else if (val.length \u003e 3) {\n            \n            var tmp \u003d capitalizeFirstLetter(val).slice(0,3)\n            \n            for (var m in month_names) { if (tmp \u003d\u003d month_names[m]) { var month \u003d month_names[m] } } } \n        \n        else if (val.length \u003d\u003d 3) { var month \u003d capitalizeFirstLetter(val) }\n        \n      \n      } else if (i \u003d\u003d 7) { var date \u003d val   // idx 7 for day number\n      \n      } else if (i \u003d\u003d 9) {                  // idx 9 for hour\n\n        // check for any regex errors parsing time values\n        var tmp \u003d fixTimeRegex(val, datetime_match[10])\n        var val \u003d tmp[0]\n        datetime_match[10] \u003d tmp[1]\n        \n        // convert 12-hr time to 24-hr time\n        var hour \u003d convertTo24(val, datetime_match[11])\n        \n      } else if (i \u003d\u003d 10) { var min \u003d val } // idx 10 for min\n    }\n  }  \n  \n  Logger.log(\"Request: \"+month + \" \" + date + \" \" + hour+\":\"+min)\n  return [month, date, hour, min]\n}\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: enter request into master request spreadsheet\nfunction enterRequestInSpreadsheet(from, pset, subpset, info, sheet_id) {\n\n  var timestamp \u003d new Date()\n  \n  var month_val \u003d info[0]\n  var date_val \u003d info[1]\n  var full_date \u003d \"\u0027\" + month_val + \u0027 \u0027 + date_val\n  \n  var hour_val \u003d info[2]\n  var min_val \u003d info[3]  \n  var full_time \u003d hour_val + \u0027:\u0027 + min_val + \":00\"\n  \n  if (subpset \u003d\u003d \"\") { subpset \u003d \"Not sure/All of them\" }\n  \n  var sheet \u003d SpreadsheetApp.openById(sheet_id)\n  \n  sheet.appendRow([timestamp, from, pset, subpset, full_date, full_time])\n  \n}\n\n//####################################################################################################\n//####################################################################################################\n\n/////////////////////////////////////////\n/////                             ///////\n/////  MAIN EMAIL CHECK FUNCTION  ///////\n/////                             ///////\n/////////////////////////////////////////\n\n//####################################################################################################\n//####################################################################################################\n\n// purpose: scan inbox for messages with pset requests, add to spreadsheet\nfunction getEmailRequests() {\n   \n  var sheet_id \u003d getSpreadsheetId()\n  var prev_timestamp \u003d getMostRecentTimestamp(sheet_id)\n  \n  var inbox \u003d GmailApp.getInboxThreads()\n  \n  for (var idx in inbox) {\n    \n    var thread \u003d inbox[idx]\n    \n    if (matchThreadSubject(thread)) {\n      \n      var msgs \u003d thread.getMessages()\n      \n      for (var idx2 in msgs) {\n        \n        var this_timestamp \u003d msgs[idx2].getDate()\n        \n        Logger.log(\u0027THIS TIMESTAMP: \u0027+this_timestamp)\n        //Logger.log(\u0027BOOL: \u0027+(prev_timestamp \u003c this_timestamp))  //CHANGE THIS TO prev \u003c this !!!!\n        if (prev_timestamp \u003c this_timestamp) {\n          \n          var msg \u003d msgs[idx2]\n          \n          var from \u003d getFrom(msg)\n          \n          // parse the body of the email for relevant details to enter in spreadsheet\n          var body \u003d msg.getPlainBody()\n          \n          // first scrape pset info\n          var tmp \u003d getPset(body)\n          var pset \u003d tmp[0]\n          var sub_pset \u003d tmp[1]\n          var pset_pattern \u003d tmp[2]\n          \n          // now scrape date/time info\n          var datetime_info \u003d getDateTimeInfo(pset_pattern, body) \n          \n          //enterRequestInSpreadsheet(from, pset, sub_pset, datetime_info, sheet_id)\n          \n          Logger.log(\u0027From: \u0027+from)\n          Logger.log(\u0027Pset: \u0027+ pset + sub_pset)\n          Logger.log(\u0027 \u0027)\n        } \n      }\n    }\n  }\n}\n"}]}